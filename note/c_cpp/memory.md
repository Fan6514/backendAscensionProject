# C/C++ 内存管理

Linux 系统在装载 elf 格式的程序文件时，会调用 loader 把可执行文件中的各个段依次载入到从某一地址开始的空间中。

用户程序可以直接使用系统调用来管理 heap 和mmap 映射区域，但更多的时候程序都是使用 C 语言提供的 malloc()和 free()函数来动态的分配和释放内存。stack区域是唯一不需要映射，用户却可以访问的内存区域。

## 进程内存布局

计算机系统分为32位和64位，而32位和64位的进程布局是不一样的，即使是同为32位系统，其布局依赖于内核版本，也是不同的。以x86平台Linux进程内存分布为例，内存空间从低地址到高地址依次为：代码段、（初始化）数据段、（未初始化）数据段（BSS）、堆、mmap、栈、命令行参数和环境变量。其中堆的内存空间向高地址生长，栈的内存空间向低地址生长。

C语言中几种变量类型：全局变量、局部变量和静态变量。C函数默认为全局函数，在其他“.c”文件中需要使用关键字 `extern` 修饰声明，如果需要定义为静态函数只作用于本文件中，需要使用关键字 `static` 修饰声明。

- 栈区（Stack）— 存储程序执行期间的本地变量和函数的参数，从高地址向低地址生长
- 堆区（Heap）动态内存分配区域，通过 malloc、new、free 和 delete 等函数管理
- 未初始化变量区（BSS）— 存储未被初始化的全局变量和静态变量
- 数据区（Data）— 存储在源代码中有预定义值的全局变量和静态变量
- 代码区（Text）— 存储只读的程序执行代码，即机器指令

用户程序可以直接使用系统调用来管理 heap 和mmap 映射区域，但更多的时候程序都是使用 C 语言提供的 malloc()和 free()函数来动态的分配和释放内存。stack区域是唯一不需要映射，用户却可以访问的内存区域。

操作系统提供了相关的系统调用来完成内存分配工作。

- 对于heap的操作，操作系统提供了brk()函数，c运行时库(glibc)提供了sbrk()函数。
- 对于mmap映射区域的操作，操作系统提供了mmap()和munmap()函数。

sbrk()，brk() 或者 mmap() 都可以用来向我们的进程添加额外的虚拟内存。而glibc就是使用这些函数来向操作系统申请虚拟内存，以完成内存分配的。

> 内存的延迟分配，只有在真正访问一个地址的时候才建立这个地址的物理映射，这是 Linux 内存管理的基本思想之一。Linux 内核在用户申请内存的时候，只是给它分配了一个线性区（也就是虚拟内存），并没有分配实际物理内存；只有当用户使用这块内存的时候，内核才会分配具体的物理页面给用户，这时候才占用宝贵的物理内存。内核释放物理页面是通过释放线性区，找到其所对应的物理页面，将其全部释放的过程。

## 内存分配和管理

C 语言为内存的分配和管理提供了几个函数，声明在 <stdlib.h> 头文件中。

|  函数   | 描述  |
|  ----  | ----  |
| void *calloc(int num, int size);  | 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。 |
| void free(void *address);  | 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。 |
| void *malloc(int num);  | 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。 |
| void *realloc(void *address, int newsize);  | 该函数重新分配内存，把内存扩展到 newsize。 |

## 内存泄漏

内存只申请不释放不一定就是内存泄漏，有可能是程序必须要申请很多内存，而如果是因为 bug 导致申请了很多内存， 这就是内存泄漏了，或称为 space leak，即申请的内存超过了正常所需 。

 有很多情况会导致内存泄漏，像重复使用的某个结构体/对象，当再次复用时没有清理上一次使用遗留的数据、系统中存在cache，但cache的过期策略设置不得当等等。 

1.  **内存无法删除**

申请了一些内存，但最终却没有什么指向它们：

```c
void memory_leak()
{
	char* mem = (char*)malloc(1024);
	// just return
}
```

 在这段代码中我们申请了1k内存，**然而当memory_leak函数返回后你就再也不知道这段内存到底在哪里了**。  因此在**这种情况下你没有办法再找到这些内存并将其删除**。 

2.  ##### **内存碎片**

 对于现代操作系统尤其具备虚拟内存能力的系统来说 ， 内存碎片问题通常不是特别严重的问题。因为我们在虚拟内存中存放的连续内存可能在物理内存上是另一种方式存储。

利用虚拟内存我们可以更加充分灵活的利用“边边角角”的物理内存，从而减少内存碎片带来的影响。关于虚拟内存更详细的讲解你可以参考《深入理解操作系统》虚拟内存一章。

 如果你的程序需要重复申请很多对象/数据/结构体，并在最后一次性全部释放，那么内存池是一个避免内存碎片不错的选择，原理在于尽管从内存池的角度看会有碎片，但当我们以内存池大小为单位从堆区中申请释放内存时，这种碎片将不复存在。 

内存池可以参考文章 《[高性能服务器内存池是如何实现的](http://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&mid=2247485720&idx=1&sn=ea066dfd5df1edc180aca93c2a84f9a2&chksm=cfe99598f89e1c8e55511f187b8d5bb522abba817582f760d8124cf4b7d637a68121b4cc697a&scene=21#wechat_redirect)》 。

 对于长时间运行的服务器端程序、数据库程序、操作系统等，内存泄漏就属于比较严重的问题了，因为这些程序必须时刻在线，任何微小的内存泄漏在时间的加持下都会非常明显。 

内存的申请速度会对系统性能产生很大的影响，当系统内存不足时，内存分配器找到一块满足要求的空闲内存块将更加困难耗时更多，当程序消耗的内存超过物理内存大小时虚拟内存系统（如果有的话）开始发挥作用，将进程地址空间中不常用的一部分swap出去，此时系统性能将快速下降，表现出来的就是程序员运行变慢、卡顿。

当然，根据系统配置，像Linux系统，可能会将消耗内存很多的进程kill掉，这就是Out of Memory killer，简称oom killer。

