## 多线程下的析构函数

使用同步原语保护类的内部状态，即可编写线程安全的类，但对象的构造和析构不能由自身的互斥器保护。如何避免对象析构时可能产生的**竞态条件**时 C++ 多线程编程面临的基本问题。

>   竞态条件：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就存在竞态条件。
>
>   -   析构对象时，如何得知没有其他线程正在执行该对象的成员函数
>   -   如何保证执行成员函数时，对象不会对另一个线程析构
>   -   调用某个对象的成员函数时，如何得知对象未被析构

线程安全的类需要满足以下三个条件：

-   多个线程同时访问时，其表现出正确的行为
-   操作系统调用线程，线程的执行顺序无关
-   调用端代码无需额外的同步或协调动作

### 对象构造的线程安全

对象构造时的线程安全，要求在构造期间不泄露 this 指针：

-   不在构造函数中注册任何回调
-   不要在构造函数中把 this 指针传给跨线程的对象

构造函数执行期间对象还没有完成初始化，如果 this 泄漏给其他对象，其他线程就可能访问到这个未构造完成的对象。

多线程下正确的构造方法应该是构造函数+initialize()的方式，构造函数不需要主动抛出异常，调用方靠 initialize() 的返回值来判断对象是否构造成功。

### 对象析构的线程安全

作为类数据成员的互斥器 MutexLock 只能保证类中其他数据成员读写时的线程安全，但在对象析构中使用时，遇到一个线程执行到析构函数将互斥器已经释放，而另一个函数正调用该对象的成员函数时，就可能永远阻塞下去，可能进入临界区然后 core dump，或者发生其他未知的错误。

引用另外一层**间接层对象**来管理共享资源时编写线程安全的惯用法。`shared_ptr` 时引用计数智能指针，`shared_ptr<T>` 是一个类模板，只有一个类型参数。**引用计数是自动化资源管理的常用手段**，当引用计数降为 0 时，对象（资源）即被销毁。`weak_ptr` 也是一个引用计数智能指针，但不增加对象的引用次数，即**弱引用**。

-   `shared_ptr` 是强引用，只要有一个指向对象的 `shared_ptr` 存在，该对象就不会析构。当指向对象的最后一个 `shared_ptr` 析构或 `reset()` 时，对象保证会析构。
-   `weak_ptr` 不控制对象的生命期，但知道对象是否还存在。如果对象还存在，可以提升为有效的 `shared_ptr`；否则会返回一个空的 `shared_ptr`。
-   智能指针的计数是原子性的。

`shared_ptr` 也存在线程安全的问题，它的引用计数本身是安全无锁的，但对象的读写则不是。一个 `shared_ptr` 对象实体可被多个线程同时读取，两个 `shared_ptr` 对象实体可以被两个线程同时写入，如果多个线程读写同一个 `shared_ptr` 对象需要加锁。

多线程同时访问一个 `shared_ptr`，正确做法是用 mutex 保护：

```cpp
MutexLock mutex;
shared_ptr<Foo> globalPtr;	// 多个线程访问读写
// 读操作
void read()
{
    shared_ptr<Foo> localPtr;
    {
        MutexLockGuard lock(mutex);
        localPtr = globalPtr;
    }
    doit(localPtr);
}
// 写操作
void write()
{
    shared_ptr<Foo> newPtr(new Foo);
    {
        MutexLockGuard lock(mutex);
        globalPtr = newPtr;
    }
    doit(newPtr);
}
```

