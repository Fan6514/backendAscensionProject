# 指针使用须知

## 基本概念

指针可以理解为内存的地址，我们定义的变量的地址就可以用指针来存储，通过对指针的解引用可以得到变量在内存中存储的值。

在 C、C++ 中指针的使用是编程中需要特别注意的地方，包括一些结构体的传参，数据量较大的字符串，数组名传递到函数中退化为指针等情况。

数组名可以访问数组元素，将数组名赋值给指针，也可以通过指针来访问。在访问数组时，尤其是使用指针后需要格外注意数组的长度，避免数组越界问题。

**数组名与指针的区别**：数组名与指针是不同的概念，数组名代表的是一个数组，其值为该数组的首地址。当我们对数组名进行解引用时会发现编译错误，因此数组名和指针是不同的。实际上，我们定义的指针通常为指针变量，而数组名只是一个指针常量，其值是不能修改的，不能进行类似 `arr++` 的操作。

**指针常量和常量指针的区别**：

- 指针常量（int *const ptr）：实质是一个常量，该常量为指针类型，也就是说指针存储的值（地址）无法改变。
- 常量指针（const int *ptr）：实质是一个指针，该指针指向一个常量，也就是说指针的指向可以改变，但原来指向变量的值无法改变。

```c
int *const ptr = NULL;
const int *ptr = NULL;
```

> 对于数组来说，操作符 `sizeof(arr)` 可以返回数组的长度，但是退化为指针后，`sizeof(ptr)` 成为了指针类型的长度。因此在代码重构过程中需要注意一些在 memset、memcpy 等函数中使用了 sizeof 操作符的地方，如果将数组改为指针后要将 sizeof 部分修改为实际操作的长度，否则会导致数据被截断。

## 内存的开辟与释放

通常我们定义一些变量在程序运行时存放在栈中，但栈的大小是有限的，如果需要使用大内存的变量时我们可以通过使用 `malloc` 来在堆内存中开辟一块空间来使用。栈中的内存会在函数调用结束后被释放，而堆中开辟的内存则需要调用 `free` 手动释放，采用“谁开辟谁释放”的原则。

`malloc` 函数返回一个 void 指针，在C语言中void类型被定义为可以转换为任何一种类型，所以我们只要转换为需要的类型指针。被释放后的指针仍然会指向原来开辟的内存地址，因此我们需要在释放后令该指针置空，以免出现**野指针**现象。

## 深拷贝与浅拷贝

