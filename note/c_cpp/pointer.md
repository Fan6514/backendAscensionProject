# 指针使用须知

## 基本概念

指针是一个特殊的变量，可以理解为内存的地址，我们定义的变量的地址就可以用指针来存储，通过对指针的解引用可以得到变量在内存中存储的值。

要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。

```cpp
int*ptr;  
char*ptr;  
int**ptr;  
int(*ptr)[3];  
int*(*ptr)[4];
```

### 指针的类型

从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：

```cpp
int *ptr; //指针的类型是int *  
char *ptr; //指针的类型是char *  
int **ptr; //指针的类型是 int ** 
int (*ptr)[3]; //指针的类型是 int(*)[3]  
int *(*ptr)[4]; //指针的类型是 int *(*)[4]
```

### 指针指向的类型

当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。

从语法上看，你只需把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：

```cpp
int *ptr; //指针所指向的类型是int  
char *ptr; //指针所指向的的类型是char 
int **ptr; //指针所指向的的类型是 int *  
int (*ptr)[3]; //指针所指向的的类型是 int()[3]  
int *(*ptr)[4]; //指针所指向的的类型是 int *()[4]
```

在指针的算术运算中，指针所指向的类型有很大的作用。

指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C越来越熟悉时，你会发现，把与指针搅和在一起的“类型”这个概念分成“指针的类型”和“指针所指向的类型”两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。

**指针常量和常量指针的区别**：

- 指针常量（int *const ptr）：实质是一个常量，该常量为指针类型，也就是说指针存储的值（地址）无法改变。
- 常量指针（const int *ptr）：实质是一个指针，该指针指向一个常量，也就是说指针的指向可以改变，但原来指向变量的值无法改变。

```c
int *const ptr = NULL;
const int *ptr = NULL;
```

### 指针的值

指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。

指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。

指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。

### 指针本身所占据的内存区

以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指向的类型是什么？该指针指向了哪里？

指针本身占了多大的内存？你只要用函数sizeof(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。

## 指针运算

### 指针的算术运算

指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。例如：

```cpp
char a[20];  
int *ptr=a;  
ptr++;
```

在上例中，指针ptr的类型是int*,它指向的类型是int，它被初始化为指向整形变量a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针ptr的值加上了sizeof(int)，在32位程序中，是被加上了4。由于地址是用字节做单位的，故ptr所指向的地址由原来的变量a的地址向高地址方向增加了4个字节。

总结一下，一个指针ptrold加上一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值增加了n乘sizeof(ptrold所指向的类型)个字节。就是说，ptrnew所指向的内存区，将比ptrold所指向的内存区，向高地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。一个指针ptrold减去一个整数n后，结果是一个新的指针ptrnew，ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同。ptrnew的值将比ptrold的值，减少了n乘sizeof(ptrold所指向的类型)个字节，就是说，ptrnew所指向的内存区，将比ptrold所指向的内存区，向低地址方向移动了n乘sizeof(ptrold所指向的类型)个字节。

### 运算符&和*

这里&是取地址运算符，**是...书上叫做“间接运算符”。&a的运算结果是一个指针，指针的类型是a的类型加个**，指针所指向的类型是a的类型，指针所指向的地址嘛，那就是a的地址。总之p的结果是p所指向的东西，这个东西有这些特点：它的类型是p指向的类型，它所占用的地址是p所指向的地址。

```cpp
int a=12;  
int b;  
int *p;  
int **ptr;  
p=&a;/* &a的结果是一个指针，类型是int*，
        指向的类型是int，指向的地址是a的地址。 */
*p=24;/* *p的结果，在这里它的类型是int，
        它所占用的地址是p所指向的地址，显然，*p就是变量a。 */
ptr=&p;/* &p的结果是个指针，该指针的类型是p的类型加个*，
        在这里是int**。该指针所指向的类型是p的类型，这里是int*。
        该指针所指向的地址就是指针p自己的地址。 */
*ptr=&b;/* *ptr是个指针，&b的结果也是个指针，
        且这两个指针的类型和所指向的类型是一样的，
        所以?amp;b来给*ptr赋值就是毫无问题的了。 */
**ptr=34;/* *ptr的结果是ptr所指向的东西，
        在这里是一个指针，对这个指针再做一次*运算，
        结果就是一个int类型的变量。 */
```

## 指针表达式

一个表达式的最后结果如果是一个指针，那么这个表达式就叫指针表达式。下面是一些指针表达式的例子：

```cpp
int a,b;  
int array[10];  
int *pa;  
pa=&a;//&a是一个指针表达式。
int **ptr=&pa;//&pa也是一个指针表达式。
*ptr=&b;//*ptr和&b都是指针表达式。
pa=array;  
pa++;//这也是指针表达式。


char *arr[20];  
char **parr=arr;//如果把arr看作指针的话，arr也是指针表达式  
char *str;  
str=*parr;//*parr是指针表达式  
str=*(parr+1);//*(parr+1)是指针表达式  
str=*(parr+2);//*(parr+2)是指针表达式
```

由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。

好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。在例七中，&a不是一个左值，因为它还没有占据明确的内存。`*ptr`是一个左值，因为`*ptr`这个指针已经占据了内存，其实`*ptr`就是指针pa，既然pa已经在内存中有了自己的位置，那么*ptr当然也有了自己的位置。

## 数组和指针的关系

在 C、C++ 中指针的使用是编程中需要特别注意的地方，包括一些结构体的传参，数据量较大的字符串，数组名传递到函数中退化为指针等情况。

数组名可以访问数组元素，将数组名赋值给指针，也可以通过指针来访问。在访问数组时，尤其是使用指针后需要格外注意数组的长度，避免数组越界问题。

**数组名与指针的区别**：数组名与指针是不同的概念，数组名代表的是一个数组，其值为该数组的首地址。当我们对数组名进行解引用时会发现编译错误，因此数组名和指针是不同的。实际上，我们定义的指针通常为指针变量，而数组名只是一个指针常量，其值是不能修改的，不能进行类似 `arr++` 的操作。

> 对于数组来说，操作符 `sizeof(arr)` 可以返回数组的长度，但是退化为指针后，`sizeof(ptr)` 成为了指针类型的长度。因此在代码重构过程中需要注意一些在 memset、memcpy 等函数中使用了 sizeof 操作符的地方，如果将数组改为指针后要将 sizeof 部分修改为实际操作的长度，否则会导致数据被截断。

## 指针和结构类型的关系

可以声明一个指向结构类型对象的指针。

```cpp
struct MyStruct  
{  
int a;  
int b;  
int c;  
}  
MyStruct ss={20,30,40};//声明了结构对象ss，并把ss的三个成员初始化为20，30和40。
MyStruct *ptr=&ss;//声明了一个指向结构对象ss的指针。它的类型是MyStruct*,它指向的类型是MyStruct。
int *pstr=(int*)&ss;//声明了一个指向结构对象ss的指针。但是它的类型和它指向的类型和ptr是不同的。
```

所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个“填充字节”，这就导致各个成员之间可能会有若干个字节的空隙。

## 内存的开辟与释放

通常我们定义一些变量在程序运行时存放在栈中，但栈的大小是有限的，如果需要使用大内存的变量时我们可以通过使用 `malloc` 来在堆内存中开辟一块空间来使用。栈中的内存会在函数调用结束后被释放，而堆中开辟的内存则需要调用 `free` 手动释放，采用“谁开辟谁释放”的原则。

`malloc` 函数返回一个 void 指针，在C语言中void类型被定义为可以转换为任何一种类型，所以我们只要转换为需要的类型指针。被释放后的指针仍然会指向原来开辟的内存地址，因此我们需要在释放后令该指针置空，以免出现**野指针**现象。


