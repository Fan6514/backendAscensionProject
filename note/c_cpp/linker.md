## 深入理解链接器

>   本文引用“码农的荒岛求生”的系列文章[《彻底理解链接器》](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg4OTYzODM4Mw==&action=getalbum&album_id=1923374391426416642&scene=173&from_msgid=2247485637&from_itemidx=1&count=3&nolastread=1#wechat_redirect)，通过学习系统整理出来，以便复习。

什么是链接器（Linker）： **链接器**是一个将编译器产生的目标文件打包成可执行文件，或者库文件，或者目标文件的程序。 

-   链接器本质上也是一个程序，本质上和我们经常使用的普通程序没什么不同；
-   链接器的输入是编译器编译好的目标文件；
-   链接器在将目标文件打包处理后，生成或者可执行文件，或者库，或者目标文件。

链接器就像压缩软件一样，将一堆目标文件打包为一个文件。

所有的应用程序都是链接器将所需要的一个个简单的目标文件汇集起来形成的， 链接器的工作过程如下：

-    链接器对给定的目标文件或库的集合进行**符号决议**以确保模块间的依赖是正确的；
-    链接器将给定的目标文件集合进行**拼接打包**成需要的库或最终可执行文件 ；
-    链接器对链接好的库或可执行文件进行**重定位**。

### 符号决议

符号决议过程中， 链接器需要做的工作就是**确保所有目标文件中的符号引用都有唯一的定义**。首先我们要清楚典型的 c 文件中有哪些。

源文件的变量包括：

-   全局变量： 只要程序没有结束运行，全局变量都可以随时使用。  用 static 修饰的全局变量，其生命周期也等同于程序的运行周期，只是这种全局变量只能在所被定义的文件当中使用，对其它文件不可见。 
-   局部变量： 局部变量只能在相应的函数内部使用，当函数调用完成后该函数中的局部变量也就无法使用了。局部变量只存在与函数的栈帧中，函数调用后相应的栈帧会被回收。

源文件编译后形成对应的目标文件，其本质包括两部分：

-   代码部分： 这里的代码指的是计算机可以执行的机器指令，也就是源文件中定义的所有函数。
-    数据部分 ： 源文件中定义的全局变量。如果是已经初始化后的全局变量，该全局变量的值也存在于数据部分。

局部变量是函数私有的，局部变量只能在该函数内部使用，而全局变量没有这个限制的。所以函数私有的**局部变量被放在了代码段中**，作为机器指令的操作数。 

编译器在遇到外部定义的全局变量或函数时，只要在当前文件中找到其声明，编译器就认为编译正确，而寻找变量定义的工作交给了链接器。其中链接器的一项工作就是确定所**使用的变量要有唯一的定义**。

**符号表**

虽然编译器留给了链接器一项任务，但编译器为了链接器工作轻松一点，制作了符号表（ Symbol table ）。

符号表中保存的信息有两部分：

-   该目标文件中引用的全局变量以及函数
-   该目标文件中定义的全局变量以及函数

 编译器在编译过程中每次遇到一个全局变量或者函数名都会在符号表中添加一项，最终编译器会统计出如下所示的一张符号表： 

|    名字     |     类型     | 是否被外部引用 |  区域  |
| :---------: | :----------: | :------------: | :----: |
| global_int  | 引用，未定义 |                |        |
| extern_func | 引用，未定义 |                |        |
| static_int  |     定义     |       否       | 数据段 |
| static_func |     定义     |       否       | 代码段 |
|  local_int  |     定义     |       否       | 数据段 |

其中 `global_int` 和 `extern_func` 是外部定义的全局变量和函数，当前文件中只是声明，编译器并没有找到其定义。剩余的变量编译器都可以在当前文件中找到其定义。 

`static_func` 为当前文件定义的局部函数，因此在代码段；剩余的符号都是全局变量，因此在数据段。

在C语言中**经static修饰**过的函数以及变量都是当前**文件私有**的，对外部不可见 。

有了符号表，编译生成的目标函数就由以下三部分构成：

![](/note/c_cpp/pics/objectfile.png)

有了符号表，链接器就可以进行符号决议了。 

**符号决议的过程**

符号表给链接器提供了两种信息，一个是当前目标文件可以提供给其它目标文件使用的符号，另一个其它目标文件需要提供给当前目标文件使用的符号。有了这些信息链接器就可以进行符号决议了。 

假设链接器需要链接三个目标文件 ，链接器会依次扫描每一个给定的目标文件，同时链接器还维护了两个集合，一个是已定义符号集合D，另一个是未定义符合集合U，下面是**链接器进行符合决议**的过程： 

-   对于当前目标文件，查找其符号表，并将已定义的符号并添加到已定义符号集合D中。 
-   对于当前目标文件，查找其符号表，将每一个**当前目标文件引用的符号与已定义符号集合D进行对比**，如果该符号不在集合D中则将其添加到未定义符合集合U中。 
-   当所有文件都扫描完成后，如果为定义符号集合U不为空，则说明当前输入的目标文件集合中有未定义错误，链接器报错，整个编译过程终止。 

 一句话概括就是只要每个目标文件所引用变量都能在其它目标文件中找到唯一的定义，整个链接过程就是正确的 。

假设 math.c 的数字计算程序，其中定义了一个 add 函数，该函数在 main.c 中被引用到。 我们只需要在 main.c 中 include 写好的 math.h 头文件就可以使用add函数了，如图所示：

![](/note/c_cpp/pics/reference.png)

将这里 math.c 文件中的代码注释掉之后再重新编译，就会出现 undefined reference to 'add(int, int)' 错误，如图所示： 

![](/note/c_cpp/pics/undefine.png)

该错误产生的过程如下：

-   链接器通过检查符号表发现代码 main.o 中引用了外部定义的 add 函数， 所以链接器开始查找add函数到底是在哪里定义的。
-   链接器去 math.o 的目标文件符号表中查找，没有找到add函数的定义。
-   链接器转而去其它目标文件符号表中查找，同样没有找到add函数的定义 。
-   链接器在所有的目标文件符号表中都没有查找到 add 函数， 因此链接器停止工作并报出错误 undefined reference to `add(int, int)'。

综上所述，链接器在符号决议中会进行如下的排查工作：

-   函数的函数名 add 有没有写正确。
-   链接命令中有没有包含 math.o，如果没有添加上该目标文件。
-   如果链接命令没有问题，查看 math.c 中定义的 add 函数定义是否有问题。 
-   如果是 C 和 C++ 混合编程时，确保相应的位置添加了 extern "C"。 

### 库与可执行文件的生成

链接器可操作的最小单元为目标文件，无论是静态库、动态库还是可执行文件，都是基于目标文件构建出来的。给定目标文件及链接选项，链接器可以生产两种库，分别为静态库和动态库。

**静态库**

静态库在Windows下是以.lib为后缀的文件，Linux下是以.a为后缀的文件。

静态库可以简单理解为一堆目标文件打包的集合，使用者只需要使用其中的函数而无需关注函数是来自哪个目标文件（由链接器来定位，用到哪个就链接哪个）。

**静态链接**：静态库是链接器通过静态链接将其和其他目标文件合并成可执行文件的。静态库不过是将多个目标文件进行打包，链接时只取静态库用到的目标文件。静态链接生成的可执行文件在运行时不依赖任何其它代码。

![](/note/c_cpp/pics/staticlib.png)

**静态链接生成可执行文件**

目标文件分为三段：代码段、数据段和符号表。

可执行文件的特点包括：

-   可执行文件和目标文件一样，由代码段和数据段组成
-   每个目标文件数据段合并到可执行文件的数据段，每个目标文件的代码段合并到可执行文件的代码段
-   目标文件的符号表不合并到可执行文件中，不需要这些字段

可执行文件区别于目标文件的地方在于，**可执行文件有一个入口函数**，这个函数也就是我们在C语言当中定义的 main 函数，main 函数在执行过程中会用到所有可执行文件当中的代码和数据。而这个 main 函数是被操作系统(Operating System) 调用执行的。

静态链接会将用到的目标文件直接合并到可执行文件当中，生成的所有可执行文件当中都有一份一模一样的代码和数据。假设静态库为 2M，那么 500 个可执行文件就有 1G 的数据是重复的。

**制作和使用静态库**：

```shell
# 制作静态库
gcc -c test.c				# 编译成可重定位文件，即生成.o文件
readelf -h test.o			# 查看可重定位文件
ar -rcs libtest.a test.o	 # 库名一般以.a为扩展名，以lib开头
ar -t libtest1.a  			#查看内容
# 使用静态库
gcc -o main main.c -L $LIB_PATH -ltest
```

 其中-L用于指定链接库的路径，由于我们要链接的库名为 `libtest.a`，在链接的时候，去掉开头的 `lib` 和后缀 `.a`，前面再加 l，就变成了 `-ltest`，其他库也是类似。 

**动态库**

动态库(Dynamic Library)，又叫共享库(Shared Library)，动态链接库等， 在 Windows 下为 DLL 文件，Windows 系统下大量使用了动态库。在 Linux 下动态库是以 .so 为后缀的文件，同时以 lib 为前缀，比如进行数字计算的动态库 Math，编译链接后产生的动态库就叫做 libMath.so。

动态库也是库，本质上动态库同样包含我们已经熟悉的代码段、数据段、符号表。只不过动态库的使用方式以及使用时间和静态库不太一样。

动态库允许使用该库的可执行文件**仅包含对动态库的引用而无需将该库拷贝到可执行文件当中**。也就是说，同静态库进行整体拷贝的方式不同，对于动态库的使用仅仅需要可执行文件当中包含必要的信息即可，为了方便理解，你可以将可执行文件当中保存的必要信息仅仅理解为需要记录动态库的名字就可以了，如图所示，同静态库相比，动态库的使用减少了可执行文件的大小。 

![](/note/c_cpp/pics/dynamiclib.png)

**动态链接**：动态链接可以在两种情况下被连接使用，分别是 load-time dynamic linking (加载时动态链接) 以及 run-time dynamic linking(运行时动态链接) 

**加载时动态链接**：加载指的是程序的加载，就是把可执行文件从磁盘搬到内存的过程，因为程序最终都是在内存中被执行的。

**当把可执行文件复制到内存后**，且在程序开始运行之前，操作系统会查找可执行文件依赖的动态库信息(主要是动态库的名字以及存放路径)，找到该动态库后就将该动态库从磁盘搬到内存，并进行符号决议，如果这个过程没有问题，那么一切准备工作就绪，程序就可以开始执行了，如果找不到相应的动态库或者符号决议失败，那么会有相应的错误信息报告为用户，程序运行失败。比如Windows下比较常见的启动错误问题，就是因为没有找到依赖的动态库。Linux下同样会有类似信息提示用户程序启动失败。 

加载时动态链接可以分为两个阶段：

-   阶段一：将动态库信息写入可执行文件；
    -   在编译链接生成可执行文件时，需要将使用的动态库加入到链接选项当中，比如在Linux下引用libMath.so，就需要将libMath.so加入到链接选项当中（比如 libMath.so 放到了 /usr/lib 下，那么使用命令 `gcc ... -lMath -L/user/lib ...` 进行编译链接），所以使用这种方式生成的可执行文件中保存了依赖的动态库信息，在Linux可使用一个简单的命令 `ldd` 来查看。 
-    阶段二：加载可执行文件时依据动态库信息进行动态链接
    -   由于在阶段一生成的可执行文件中保存了动态库信息，当可执行文件加载完成后，就可以依据此信息进行中动态库的查找以及符号决议了。

**运行时动态链接**：运行时动态链接则不需要在编译链接时提供动态库信息，也就是说，在可执行文件被启动运行之前，可执行文件对所依赖的动态库信息一无所知，只有当程序运行到需要调用动态库所提供的代码时才会启动动态链接过程。 

使用特定的 API 来运行时加载动态库，在 Windows 下通过 LoadLibrary 或者 LoadLibraryEx，在 Linux 下通过使用 dlopen、dlsym、dlclose 这样一组函数在运行时链接动态库。当这些 API 被调用后，同样是首先去找这些动态库，将其从磁盘 copy 到内存，然后查找程序依赖的函数是否在动态库中定义。这些过程完成后动态库中的代码就可以被正常使用了。 

**动态链接生成可执行文件**

在动态链接下，链接器并不是将动态库中的代码和数据拷贝到可执行文件中，而是将动态库的必要信息写入了可执行文件，这样当可执行文件在加载时就可以根据此信息进行动态链接了。

在动态链接下，可执行文件当中会新增两段，即d ynamic 段以及 GOT（Global offset table）段。

![](/note/c_cpp/pics/so.png)

 dynamic 段中保存了可执行文件依赖哪些动态库，动态链接符号表的位置以及重定位表的位置等信息。

在编译链接过程中，可以同时使用动态库以及静态库。这两种库的使用并不冲突，那么在这种情况下生成的可执行文件中，可执行文件中包含了静态库的数据和代码，以及动态库的必要信息。

```shell
# 生成目标文件
gcc -fpic -c test.c
# 生成动态库
gcc -shared -o libtest.so test.o
# 生成可执行文件
gcc -o main main.c -L path -ltest
```

### 链接器的重定位

 可执行文件中代码以及数据的运行时内存地址是链接器指定的，例如函数调用 CPU 实际执行到这条指令时跳转到该函数对应的内存地址，然后执行函数对应的机器指令。而这个内存地址就是链接器指定的，**确定程序运行时地址的过程就是重定位**(Relocation)。

确定可执行文件中代码和数据的运行时地址是分为两个阶段的，在第一个阶段中无法确定这些地址，只有在第二个阶段才可以确定，因此就叫做重定位。

源文件首先被编译器编译生成目标文件，目标文件有三段内容：数据段、代码段以及符号表，所有的函数定义被放在了代码段，全局变量的定义放在了数据段，对外部变量的引用放到了符号表。

编译器在将源文件编译生成目标文件时可以确定一下两件事：

-   定义在该源文件中函数的内存地址
-   定义在该源文件中全局变量的内存地址

这里的内存地址是相对地址，因为目标文件并不知道最后要和哪些目标文件进行链接生成最后的可执行文件。

编译器确定了定义在该源文件中函数以及全局变量的相对地址。对于编译器不能确定的引用类变量，编译器在目标文件的 .rel.text 以及 .rel.data 段中生成相应的记录告诉链接器要修正这些变量的地址。

链接器会将所有的目标文件进行合并，所有目标文件的数据段合并到可执行文件的数据段，所有目标文件的代码段合并到可执行文件的代码段。当所有合并完成后，各个目标文件中的相对地址也就确定了。因此在这个阶段，链接器需要修正目标文件中的相对地址。

