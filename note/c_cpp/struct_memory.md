## 结构体内存的自然对齐

结构体成员在内存中是按照定义的顺序依次存储的，从结构体存储的首地址开始，每个成员放置到内存中时，例如：

```c
struct {
    int x;
    char y;
}s;
```

上述的结构体中，在32为系统下一共占 4+1=5 byte 大小，但运行程序得到结果是 8 byte 大小。现代计算机中内存空间都是按照 byte 划分，理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些**数据的首地址值是某个数k（通常它为4或8）的倍数**，这就是所谓的**内存对齐**。

### 为什么要内存对齐

内存是以 byte 为单位，但大部分处理器并不是按字节块来存取内存的，一般以双字节，四字节，8字节，16字节甚至32字节来存取内存，这些存取单位称为**内存存取粒度**。

比如4字节存取粒度的处理器取 int 类型变量（32位系统），该处理器只能从地址为 4 的倍数内存开始读取数据。

如果没有内存对齐机制，数据任意存放，现在有一个 int 变量从地址 1 开始连续存储在四个字节地址中。该处理器取数据时，要从 0 地址开始读取第一个 4 字节块，，剔除地址 0 的字节，然后从地址 4 开始读取下一个 4 字节块，剔除 5，6，7 地址的数据，最后留下的两块数据合并放入寄存器中，需要做很多工作。

现在有了内存对齐，int类型数据只能存放在按照对齐规则的内存中，处理器在取数据时一次性就能读出数据，不需要做额外的操作。

此外，并不是所有的硬件平台都能访问任意地址上的任意数据，在嵌入式开发中，对与某些硬件平台只能在某些地址取特定类型的数据，否则会抛出硬件一场。

### 内存对齐规则

每个特定平台上的编译器都有自己的默认“**对齐系数**”（也叫**对齐模数**）。  gcc中默认 `#pragma pack(4)`，可以通过预编译命令 `#pragma pack(n)`，n = 1,2,4,8,16来改变这一系数。 

**有效对齐值**：给定值 `#pragma pack(n)` 和结构体中最长数据类型长度中较小的那个。效对齐值也叫**对齐单位**。

内存对齐需要遵循的规则：

-   结构体第一个成员的**偏移量（offset）**为0，以后每个成员相对于结构体首地址的 offset 都是**该成员大小与有效对齐值中较小那个**的整数倍，如有需要编译器会在成员之间加上填充字节。 
-   **结构体的总大小**为 有效对齐值 的**整数倍**，如有需要编译器会在最末一个成员之后加上填充字节。

