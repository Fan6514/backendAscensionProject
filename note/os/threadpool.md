## 高并发中的线程与线程池的实现

程序在 CPU 中执行时，CPU 只做两件事：从内存中取出指令和执行指令，CPU 并不知道线程和进程的概念。

CPU 从程序计数器 PC（ Program Counter ） 寄存器中取出指令，这里存放的是指令在内存中的地址。PC寄存器的地址是默认自动加一的， 大部分情况下 CPU 都是一条接一条顺序执行，当遇到 if、else 时， CPU 会根据计算结果来动态改变PC寄存器中的值，这样CPU就可以正确的跳转到需要执行的指令了。

 CPU 执行的指令来自于我们定义的函数，经过**编译后才会形成CPU执行的指令**。CPU 执行一个函数时，只需要找到函数被编译后形成的第一条指令就可以了，第一条指令就是函数入口。

要想让 CPU 执行这个函数，需要把函数对应的第一条机器执行装入PC寄存器就可以了，但是这是一个繁琐的过程，需要：

-   在内存中找到一块大小合适的区域装入程序
-   找到函数入口，设置好PC寄存器让CPU开始执行程序

**操作系统**就是执行这些繁琐的工作来运行程序。机器指令需要加载到内存中执行，因此需要记录下内存的起始地址和长度；同时要找到函数的入口地址并写到PC寄存器中，因此操作系统使用 一个数据结构来记录这些信息：

```c
struct *** {
   void* start_addr;
   int len;
   void* start_point;
   ...
};
```

这个结构体用来记录程序在被加载到内存中的运行状态，称为**进程**， CPU执行的第一个函数称为 **main 函数**。

### 多线程解决的问题

进程存在的问题：

-   进程是需要占用内存空间的，如果多个进程基于同一个可执行程序，那么这些进程其内存区域中的内容几乎完全相同，这显然会造成内存的浪费。
-   涉及到了进程间通信，由于各个进程处于不同的内存地址空间，进程间通信需要借助操作系统，这就在增大编程难度的同时也增加了系统开销。

进程无非就是内存中的一段区域，这段区域中保存了**CPU执行的机器指令以及函数运行时的堆栈信息**，要想让进程运行，就把 main 函数的第一条机器指令地址写入 PC 寄存器，这样进程就运行起来了。

进程的入口函数只有一个，即 main 函数，因此进程中的机器指令**只能被一个CPU执行**。 main 函数的特殊之处无非就在于是 CPU 执行的第一个函数，除此之外再无特别之处，**我们可以把 PC 寄存器指向 main 函数，就可以把 PC 寄存器指向任何一个函数**。

**线程**的概念就是将一个进程中产生多个入口函数， 原本**属于同一个进程中的机器指令可以被多个CPU同时执行**。

![](/note/os/pics/thread1.png)

**线程是运行在所处进程的地址空间的**，这块地址空间在程序启动时已经创建完毕，同时线程是程序在运行期间创建的(进程启动后)，因此当线程开始运行的时候这块地址空间就已经存在了，线程可以直接使用。

有了线程的概念后，只需要启动进程后创建多个线程就可以让所有的 CPU 忙起来，这就是高性能、高并发的根本所在，只要创建出一定数量的线程即可。

线程之间的通信无需借助操作系统，这给程序员带来极大方便的同时也带来了无尽的麻烦。**出错的根源在于CPU执行指令时根本没有线程的概念**，多线程编程面临的**互斥**与**同步**问题需要程序员自己解决。

### 线程与内存

CPU 的 PC 寄存器指向线程的入口函数，即可将线程运行起来，创建线程的过程如下：

```cpp
// 设置线程的入口函数
thread = CreateThread(DoSomething);
// 运行线程
thread.Run();
```

函数在被执行的时产生的数据包括**函数参数**、**局部变量**、**返回地址**等信息，这些信息是保存在栈中的，线程这个概念还没有出现时进程中只有一个执行流，因此只有一个栈，这个栈的栈底就是进程的入口函数，也就是main函数，假设main函数调用了funA，funcA又调用了funcB，如图所示： 

![](/note/os/pics/proccess.png)

有了线程以后一个进程中就存在多个执行入口，即同时存在多个执行流，那么只有一个执行流的进程需要一个栈来保存运行时信息，那么很显然有多个执行流时就需要有多个栈来保存各个执行流的信息，也就是说**操作系统要为每个线程在进程的地址空间中分配一个栈**，即每个线程都有独属于自己的栈。

### 线程的使用

从生命周期的角度讲，线程要处理的任务有两类：长任务和短任务。

**长任务**： 任务存活的时间很长，比如 word 中打开文件后专门有一个线程进行写数据，当用户关闭 word 时该线程才会被销毁，这就是长任务。这种场景非常适合创建专用的线程来处理某些特定任务。

**短任务**：任务的处理时间很短，比如一次网络请求、一次数据库查询等，这种任务可以在短时间内快速处理完成。因此短任务多见于各种Server，像web server、database server、file server、mail server等，这也是互联网行业的同学最常见的场景。

段任务有两个特点：一个是**任务处理所需时间短**；另一个是**任务数量巨大**。

thread-per-request 方式： 来一个请求就创建一个线程。这种方式适合于长任务，但对于大量的短任务虽然简单，但是有这样几个缺陷：

-   操作系统创建和销毁线程是需要消耗时间的
-   每个线程需要有自己独立的栈，因此当创建大量线程时会消耗过多的内存等系统资源

因此有了线程池的概念来解决这个问题。

### 线程池实现

线程池的概念就是提前创建一些线程，之后不再释放，如果有任务就交给这些线程处理。因此无需频繁的创建、销毁线程，同时线程池中线程的数量时一定的，也不会消耗过多的内存。

线程池维护一个任务队列，生产者为提交任务，消费者是消费任务的线程。

![](/note/os/pics/threadpool.png)

 一般来说提交给线程池的任务包含两部分：**需要被处理的数据和处理数据的函数**。

```c
typedef struct Task
{
    void* arg;						// 需要处理的数据
    void (*function)(void* arg);	 // 处理数据的函数
}Task;
```

当任务队列为空时，线程池中的线程（消费者线程）会阻塞在队列上，当生产者向队列中写入数据后，线程池中的工作线程（work）会被唤醒，该线程从队列中取出上述结构体(或者对象)，以结构体(或者对象)中的数据为参数并调用处理函数：

```c
while(true)
{
	pthread_mutex_lock(&pThreadPool->mutexPool);
    while (pThreadPool->taskSize == 0)
    {// 线程池的线程阻塞在队列上
        pthread_cond_wait(&pThreadPool->notEmpty, &pThreadPool->mutexPool);
    }
    
    // 从队列中取任务
    task.function = pThreadPool->taskList[pThreadPool->taskFront].function;
    task.arg = pThreadPool->taskList[pThreadPool->taskFront].arg;
    pThreadPool->taskFront = (pThreadPool->taskFront + 1) % pThreadPool->taskCapacity;
    pThreadPool->taskSize--;
    
    pthread_cond_signal(&pThreadPool->notFull);
    pthread_mutex_unlock(&pThreadPool->mutexPool);
    /* 处理忙线程数量，开始任务 */
    pthread_mutex_lock(&pThreadPool->mutexBusy);
    pThreadPool->busyNum++;
    pthread_mutex_unlock(&pThreadPool->mutexBusy);
    
    // 执行任务
    task.function(task.arg);
    
    /* 任务结束 */
    pthread_mutex_lock(&pThreadPool->mutexBusy);
    pThreadPool->busyNum--;
    pthread_mutex_unlock(&pThreadPool->mutexBusy);
}
```

线程池的组成主要分为 3 个部分，这三部分配合工作就可以得到一个完整的线程池：

1. 任务队列，存储需要处理的任务，由工作的线程来处理这些任务

- 通过线程池提供的 API 函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除
- 已处理的任务会被从任务队列中删除
- 线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程

2. 工作的线程（任务队列任务的消费者） ，N个

- 线程池中维护了一定数量的工作线程，他们的作用是是不停的读任务队列，从里边取出任务并处理
- 工作的线程相当于是任务队列的消费者角色，
- 如果任务队列为空，工作的线程将会被阻塞 (使用条件变量 / 信号量阻塞)
- 如果阻塞之后有了新的任务，由生产者将阻塞解除，工作线程开始工作

3. 管理者线程（不处理任务队列中的任务），1个

- 它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测
- 当任务过多的时候，可以适当的创建一些新的工作线程
- 当任务过少的时候，可以适当的销毁一些工作的线程

**线程池的数量**

线程池设置的数量过少就不能充分利用 CPU，线程创建的过多反而会造成系统性能下降，内存占用过多，线程切换造成的消耗等等。

从任务所需要资源来讲，线程池处理的任务包括：**CPU 密集型和 I/O 密集型**。

-   CPU 密集型就是说处理任务不需要依赖外部 I/O，比如科学计算、矩阵运算等等。在这种情况下只要线程的数量和核数基本相同就可以充分利用 CPU 资源。
-   I/O 密集型大部分时间都用在了比如磁盘I/O、网络I/O等。

I/O 密集型任务需要利用性能测试工具评估出用在 I/O 等待上的时间，这里记为 WT(wait time)，以及 CPU 计算所需要的时间，这里记为 CT(computing time)，那么对于一个N核的系统，合适的线程数大概是 N * (1 + WT/CT)，假设 I/O 等待时间和计算时间相同，那么你大概需要 2N 个线程才能充分利用 CPU 资源，注意这只是一个理论值，具体设置多少需要根据真实的业务场景进行测试。

