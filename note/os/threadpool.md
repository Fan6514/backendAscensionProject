## 高并发中的线程与线程池的实现

程序在 CPU 中执行时，CPU 只做两件事：从内存中取出指令和执行指令，CPU 并不知道线程和进程的概念。

CPU 从程序计数器 PC（ Program Counter ） 寄存器中取出指令，这里存放的是指令在内存中的地址。PC寄存器的地址是默认自动加一的， 大部分情况下 CPU 都是一条接一条顺序执行，当遇到 if、else 时， CPU 会根据计算结果来动态改变PC寄存器中的值，这样CPU就可以正确的跳转到需要执行的指令了。

 CPU 执行的指令来自于我们定义的函数，经过**编译后才会形成CPU执行的指令**。CPU 执行一个函数时，只需要找到函数被编译后形成的第一条指令就可以了，第一条指令就是函数入口。

要想让 CPU 执行这个函数，需要把函数对应的第一条机器执行装入PC寄存器就可以了，但是这是一个繁琐的过程，需要：

-   在内存中找到一块大小合适的区域装入程序
-   找到函数入口，设置好PC寄存器让CPU开始执行程序

**操作系统**就是执行这些繁琐的工作来运行程序。机器指令需要加载到内存中执行，因此需要记录下内存的起始地址和长度；同时要找到函数的入口地址并写到PC寄存器中，因此操作系统使用 一个数据结构来记录这些信息：

```c
struct *** {
   void* start_addr;
   int len;
   void* start_point;
   ...
};
```

这个结构体用来记录程序在被加载到内存中的运行状态，称为**进程**， CPU执行的第一个函数称为 **main函数**。

### 充分利用多核

进程存在的问题：

-   进程是需要占用内存空间的，如果多个进程基于同一个可执行程序，那么这些进程其内存区域中的内容几乎完全相同，这显然会造成内存的浪费。
-   涉及到了进程间通信，由于各个进程处于不同的内存地址空间，进程间通信需要借助操作系统，这就在增大编程难度的同时也增加了系统开销。

进程无非就是内存中的一段区域，这段区域中保存了**CPU执行的机器指令以及函数运行时的堆栈信息**，要想让进程运行，就把 main 函数的第一条机器指令地址写入 PC 寄存器，这样进程就运行起来了。

进程的入口函数只有一个，即 main 函数，因此进程中的机器指令**只能被一个CPU执行**。 main 函数的特殊之处无非就在于是 CPU 执行的第一个函数，除此之外再无特别之处，**我们可以把 PC 寄存器指向 main 函数，就可以把 PC 寄存器指向任何一个函数**。

**线程**的概念就是将一个进程中产生多个入口函数， 原本**属于同一个进程中的机器指令可以被多个CPU同时执行**。

![](/note/os/pics/thread1.png)

### 线程池实现

如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。

线程池的组成主要分为 3 个部分，这三部分配合工作就可以得到一个完整的线程池：

1. 任务队列，存储需要处理的任务，由工作的线程来处理这些任务

- 通过线程池提供的 API 函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除
- 已处理的任务会被从任务队列中删除
- 线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程

2. 工作的线程（任务队列任务的消费者） ，N个

- 线程池中维护了一定数量的工作线程，他们的作用是是不停的读任务队列，从里边取出任务并处理
- 工作的线程相当于是任务队列的消费者角色，
- 如果任务队列为空，工作的线程将会被阻塞 (使用条件变量 / 信号量阻塞)
- 如果阻塞之后有了新的任务，由生产者将阻塞解除，工作线程开始工作

3. 管理者线程（不处理任务队列中的任务），1个

- 它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测
- 当任务过多的时候，可以适当的创建一些新的工作线程
- 当任务过少的时候，可以适当的销毁一些工作的线程
