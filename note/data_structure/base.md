# 认识复杂度、对数器、二分法和异或运算

## 时间复杂度和空间复杂度

评估一个程序的算法的复杂度，可以帮助我们设计出有效的算法。而评估的核心指标主要看它的时间复杂度（流程决定）、额外空间复杂度（流程决定）和常数项时间（实现细节决定）。

### 时间复杂度

要理解时间复杂度，首先理解什么是常数时间的操作。**常数时间操作**每次执行的时间都是固定时间，如数组寻址时是直接按照偏移取出数据的。反之，执行时间不固定的都不是常数时间操作。

常见的常数时间的操作包括：

- 算数运算（+、-、*、/、%等）
- 位运算（<、>、|、&、^等）
- 赋值、比较、自增、自减操作
- 数组寻址操作

通俗来讲，时间复杂度就是算法做了多少次的常数时间操作，下面看一看选择排序的过程中发生了多少次常数操作。

选择排序每一次遍历数组找到当前最小值，然后把最小值放在对应的位置上。因此该算法执行的常数操作可以表示为：

```
f(n) = (2n + 1) + (2(n - 1) + 1) + ... + 1
     = 2 * (n + n-1 + n-2 + ... + 1) + n
     = 2an^2 + bn + n + c
     = xn^2 + yn + z
```

其中x、y、z为常数。为了简化分析，我们抛弃一些低阶项和高阶项的系数，我们要做的就是计算大O运行时间。因此上述的时间复杂度表达式可以简化为O(n^2)。时间复杂度的意义在于，当我们处理的数据（即n）足够大时，低阶项和每一项的系数就变得不重要了，而真正决定表达式值的是高阶项的大小。时间复杂度就是衡量算法复杂程度的一种指标，只与数据量有关，而与之外的优化（低阶项和系数）无关。

确定算法的总操作数量与数据数量之间的表达式关系时，需要注意：

- 算法处理的数据状况要按照最差情况来看。
- 把整个流程拆分为一个个基本动作，保证每个动作都是常数时间的操作。
- 如果数据量为n，看基本动作数量和n的关系。

### 额外空间复杂度

额外空间是指与功能无关，在执行过程中需要开辟一些空间来支持算法流程的部分。

输入参数的空间与输出结果的空间不算做额外空间，除此之外，流程中如果还需要开辟空间才能执行的部分就是额外空间。如果申请的空间为有限的几个变量，则额外空间复杂度为O(1)

### 常数项时间

在相同时间复杂度的情况下，就需要查看常数项时间来衡量算法的复杂程度。而常数项时间没有必要通过理论分析，直接使用大数据运行程序来判断哪一个算法更快。

## 什么是对数器

如何确保一个算法的正确性，如果在大量的数据中有一个数据通过算法计算是错误的，但是不告诉你是哪里有问题，这时候排错的过程是非常痛苦的。对数据就是用一个绝对正确的方法和随机器生成的样本数据进行合体，如果算法是正确的，那么和对数器随机生成的元素进行对比也一定是queal的，否则返回false就说明你的算法有问题。

1. 有一个你想要测的方法a；
2. 实现一个绝对正确但是复杂度不好的方法b；
3. 实现一个随机样本产生器；
4. 实现对比算法a和b的方法；
5. 把方法a和方法b跑相同的随机样本，比对多次来验证方法a是否正确；
6. 如果有一个样本使得比对出错，打印样本分析是哪个方法出错；
7. 当样本数量很多时比对测试依然正确，可以确定方法a已经正确。

## 异或运算

异或运算：相同为0，不同为1
同或运算：相同为1，不同为0

异或运算记为无进位相加的结果，如 6 ^ 7 = 110 ^ 111 = 001。

性质：0 ^ N == N; N ^ N == 0; 异或运算满足交换律和结合律

### 不使用额外空间交换变量

前提是这两个变量的内存指向不同，如果这两个变量指向同一个值，那么结果就会被异或为0。正常项目中应该使用中间值temp来交换，避免出现歧义。

```c
int swap(int a, int b)
{
     a = a ^ b;     // a = a^b, b = b
     b = a ^ b;     // a = a^b, b = a^b^b = a
     a = a ^ b;     // a = a^b^a = b
}
```

### 数组中出现奇数次的数

1. 出现奇数次的数只有一个

思路：出现偶数次的数两两异或最后都变成了0，而异或到最后的数即为奇数次的数。

2. 出现奇数次的数有两个

思路：先按照第一个思路进行操作，可以得到这两个奇数次数的异或（a ^ b != 0），这两个数的异或必然不等于0，由此可以知道这两个数的某一位其中一个数为1，另一个数为0。按照这个思路，我们就可以把数组上的数分为该位置为1的数和该位置为0的数，此时a和b必然是被分开的。

两个数的异或为1的位置就是这两个数不同的位，我们用该数异或数组中的数，就可以找到奇数次且该位位1的那个数，然后用结果异或(a^b)就可以得到另一个数。因此，问题就成为如果找到其中1的位置。

### 找到int类型二进制最右侧1的位置

思路：对原数进行取反可以得到所有位都与原数不相同，然后加一操作后进位的位置即为我们要找的位置，此时除了进位位置，其他位置上的数都与原数不同，再进行与运算即可得到最右侧1的数。总结为`n = n & ((~n) + 1)`

```c
void findOddTimesNum2(int arr[], int length)
{
     int eor = 0;
     int rightOne = 0;
     int onlyOne = 0;
     int result[2] = {0};
     /* 先找两个数的异或 */
     for (int i = 0; i < length; i++)
     {
          eor ^= arr[i];
     }
     /* 找到两个数位为1的数 */
     rightOne = eor & (~eor + 1);
     /* 找到该位为1且出现奇数次的数 */
     for (int i = 0; i < length; i++)
     {
          /* 只找该位为1的数 */
          if ((arr[i] & rightOne) != 0)
          {
               onlyOne ^= arr[i];
          }
     }

     result[0] = onlyOne;
     result[1] = eor ^ onlyOne;
}
```

### 二进制中1的个数

思路：我们已经学到怎么提取最右侧的1，在找到最右侧的1之后，count++，然后用提取出的数异或原数，即可将该位的1置为0，直到原来的数都置为0，就找到了1的个数。